{"name":"dwm","tagline":"suckless.org's dwm with a built-in MPD client, and more","body":"This software is a X11 window manager based on suckless.org's dwm 6.0, adding a client for the music player daemon and mpv media player as well as various other gimmicks.\r\n\r\nAnd here is what it looks like (of course, the cool stuff is under the\r\nhood):\r\n\r\n![Screenshot](https://raw.githubusercontent.com/2ion/dwm/gh-pages/screenshot2.png)\r\n\r\n## PATCHES & MODIFICATIONS\r\n\r\n### 'OFFICIAL' PATCHES\r\n\r\n* pango\r\n* pertag\r\n* savefloats\r\n* pushstack\r\n* cycletag\r\n* bstack\r\n* deck layout\r\n\r\n### PERSONAL MODS\r\n\r\n* You can define filter rules to automatically set the opacity of\r\nclients (see the section further down)\r\n* Use XkbKeycodeToKeysym() instead of XKeycodeToKeysym()\r\n* mpdcmd() callback to directly control mpd. Linked against\r\nlibmpdclient. Provides multiple actions; see below for details.\r\n* mpdcmd\\_loadpos() and mpdcmd\\_savepos() callbacks to create and\r\naccess bookmarks. The state is lost when DWM exits. There are\r\n10 registers 0-9 available for storing up to 10 bookmarks.\r\n* libnotify notifications triggered by mpdcmd() actions!\r\n* DCMD() macro for convenient dmenu invocation\r\n* Compile with -O3 -march=native\r\n* wmii-like actions\r\n* MPD status change notifications\r\n* Support for IPC with the [mpv media player](https://github.com/mpv-player/mpv/blob/master/DOCS/man/ipc.rst) via UNIX\r\n  domain sockets\r\n\r\n## Building and installing\r\n\r\nBefore continueing, check out the latest tagged release version:\r\n```\r\n# Current development branch\r\ngit checkout 6.24\r\n```\r\nEvery commit that has not been tagged should be considered unstable and\r\nnot suited for productive use!\r\n\r\nDue to the extensions, we need the following extra libraries:\r\n\r\n* libxft\r\n* libpango\r\n* libpangoxft\r\n* libmpdclient\r\n* libnotify\r\n\r\nThe Makefile uses pkg-config to obtain CFLAGS and LDFLAGS. If you don't\r\nhave pkg-config insalled, you need to adjust the Make config. Then,\r\n```sh\r\nmake\r\nmake install PREFIX=$PREFIX\r\n```\r\nbuilds and installs dwm into $PREFIX.\r\n\r\n### skippy-xd\r\n\r\nThe build system will also build and install\r\n[skippy-xd](https://github.com/richardgv/skippy-xd/), a nice and small\r\nX11 task switcher (bound to Mod+Escape by default), via git-submodule.\r\nIt is by default bound to Mod4+Backspace.\r\n\r\n## Configuration premises\r\n\r\nconfig.h is tailored to my main machine, which is running Debian\r\nUnstable, and make assumptions about CPU frequencies, sudo configuration\r\netc, so you need to review the file in any case. Windowing rules have\r\nbeen broken out into rules.h.\r\n\r\nUnlike the original dwm package, the config.def.h file has been removed.\r\nIn order to modify the configuration, edit the config.h file directly.\r\n\r\n## MPD client extensions\r\n\r\nThe MPD client extension provides the following bindable callbacks:\r\n\r\n```C\r\nvoid mpdcmd(const Arg *arg);\r\nvoid mpdcmd_playpos(const Arg *arg);\r\nvoid mpdcmd_savepos(const Arg *arg);\r\n```\r\n\r\nIn config.h, the following variables affect the mpd functions'\r\nbehaviour:\r\n\r\n```C\r\n/* Connection attempts when there is no active connection */\r\nstatic const int cfg_mpdcmd_retries               = 10;\r\n\r\n/* IP address of the MPD server or path to the UNIX socket */\r\nstatic const char cfg_mpdcmd_mpdhost[]            = \"/home/joj/.mpd_socket\";\r\n\r\n/* IP port of the MPD server. Ignored when a socket is being used */\r\nstatic unsigned cfg_mpdcmd_mpdport                = 6600;\r\n\r\n/* Enable notifcations via libnotify */\r\nstatic const int cfg_mpdcmd_notify_enable         = 1;\r\n\r\n/* Connection attempts to get a connection to a notification daemon */\r\nstatic const int cfg_mpdcmd_notify_retries        = 2;\r\n\r\n/* Time notifications stay visible, in seconds */\r\nstatic const int cfg_mpdcmd_notify_timeout        = 5;\r\n\r\n/* Shell command used to mute the MPD volume, the MPD server currently\r\n * doesn't provide this functinality */\r\nstatic const char *cfg_mpdcmd_mute_command[]      = { \"amixer\", \"sset\", \"Master\", \"toggle\", NULL };\r\n\r\n/* Volume step interval when increasing/decreasing volume */\r\nstatic int voldelta                               = 4;\r\n\r\n/* MPD watcher: status query interval in microseconds */\r\nstatic const int cfg_mpdcmd_watch_interval        = 500;\r\n\r\n/* Enable or disable the MPD watcher. If enabled,\r\n * notifications when going to the previous/next song will be disabled\r\n * since the watcher looks out for the same event */\r\nstatic int cfg_mpdcmd_watch_enable                = 1;\r\n```\r\n\r\n### mpdcmd(const Arg \\*arg)\r\n\r\nControl MPD player state and volume.\r\n\r\narg needs to have its member i set to one of the following integer\r\nconstants, which are defined as an enum type in dwm.c:\r\n\r\n    MpdPlayAgain\r\n        Re-play the currently playing song from the beginning.\r\n\r\n    MpdRaiseVolume\r\n        Raise the MPD mixer volume by voldelta points. voldelta is set\r\n        in config.h.\r\n\r\n    MpdLowerVolume\r\n        Opposite of MpdRaiseVolume.\r\n\r\n    MpdMuteVolume\r\n        Toggle mute. If unmuted, the volume will be restored to the\r\n        previous level.\r\n\r\n    MpdTogglePause\r\n        Toggle play/pause.\r\n\r\n    MpdPrev\r\n        Play the previous song in the queue.\r\n\r\n    MpdNext\r\n        Play the next song in the queue.\r\n\r\n    MpdNotifySong\r\n        Displays info (title/artist/album/queue-pos/length) on the\r\n        currently playing or selected song.\r\n\r\n    MpdNotifyStatus\r\n        Displays a notification with the status of the\r\n        crossover/repeat/random/single//consume settings.\r\n\r\n    MpdNotifyVolume\r\n        Displays a notification with the current volume.\r\n\r\n    MpdToggleRepeat\r\n        Toggle the repeat flag.\r\n\r\n    MpdToggleConsume\r\n        Toggle the consume flag.\r\n\r\n    MpdToggleRandom\r\n        Toggle random playback.\r\n\r\n    MpdToggleSingle\r\n        Toggle single player mode.\r\n\r\n    MpdToggleWatcher\r\n        If the watcher is enabled, the watcher will be paused. While\r\n        the watcher is paused, regular notifications will be shown when\r\n        skipping to the previous or next song if notifications are\r\n        enabled.\r\n\r\n    MpdUpdate\r\n        Execute a full database update.\r\n\r\n### mpdcmd\\_loadpos(const Arg \\*arg) / mpdcmd\\_savepos(const Arg \\*arg)\r\n\r\nProvides 10 registers to bookmark/restore song and playing position.\r\n\r\nargs needs to have its member i set to an integer 0 through 9. A call to\r\nmpdcmd\\_savepos({.i = n}) saves the playlist index and play position of\r\nthe currently playing song (includes being paused) into register n. A\r\ncorresponding call to mpdcmd\\_loadpos({.i = n}) plays the song with the\r\npreviously saved playlist index from the saved playing position.\r\n\r\nThe current playlist will also be saved and restored in order to ensure\r\nthat the bookmark is being played correctly even if the underlying\r\nplaylist has changed in the meantime.\r\n\r\n### Notifications\r\n\r\nNotifications with information on the newly selected song are being\r\ndisplayed if notifications are enabled in config.h. Notifications are\r\ntriggered on mpdcmd()'s MpdNext and MpdPrev actions. Naturally, dwm must\r\nhave access to a running notification service via dbus. An example\r\nconfiguration for the lightweight dunst notification daemon can be found\r\nin /resources.\r\n\r\nIn config.h, the following switches can be set:\r\n\r\n```C\r\n// set to 0 or 1 to disable/enable the libnotify codepath\r\nstatic const int cfg_mpdcmd_notify_enable  = 1;\r\n\r\n// times the libnotify code should try to re-initialize if\r\n// a connection attempt to the notification service failed\r\nstatic const int cfg_mpdcmd_notify_retries = 2;\r\n\r\n// seconds how long a single notification should be kept visible\r\nstatic const int cfg_mpdcmd_notify_timeout = 5;\r\n```\r\n\r\nModifying the notification contents takes a little more effort because\r\nI decided to avoid allowing user templates in order to keep things\r\nsimple. You have to re-implement the functions\r\n\r\n```C\r\nstatic void mpdcmd_prevnext_notify(int mpdaction);\r\nstatic void mpdcmd_notify_settext(MpdcmdNotification *n,\r\n    const char *album, int pos, int queuelen, int minutes, int seconds);\r\nstatic void mpdcmd_notify_settitle(MpdcmdNotification *n,\r\n    const char *artist, const char *title);\r\n```\r\n\r\nwhere MpdcmdNotification is a defined as\r\n\r\n```C\r\ntypedef struct {\r\n  char *title;\r\n  char *txt;\r\n} MpdcmdNotification;\r\n```\r\n\r\nThe function\r\n\r\n```C\r\nstatic void mpdcmd_prevnext_notify(int mpdaction);\r\n```\r\n\r\nretrieves the metadata via libmpdclient calls and allocates a\r\nMpdcmdNotification struct. It can decide to take different actions\r\ndepending on the mpdaction it was triggered by (MpdPrev|MpdNext). It\r\nthen passes the data to\r\n\r\n```C\r\nstatic void mpdcmd_notify_settext(MpdcmdNotification *n, <metadata>);\r\nstatic void mpdcmd_notify_settitle(MpdcmdNotification *n, <metadata>);\r\n```\r\n\r\nwhich set up the title and txt fields of the MpdcmdNotification as\r\nNULL-terminated strings. They currently use snprintf() and a simple\r\nprintf-style format spec to format notification title (field: title) and\r\nbody (field: txt).\r\n\r\nFinally, mpdcmd\\_prevnext\\_notify() calls mpdcmd\\_notify() with the\r\nnotification data as the argument. This function takes care of\r\neverything needed to show the notification.\r\n\r\n## Setting the window opacity / transparency\r\n\r\nThe client filter rules have been extended and now allow setting the\r\nopacity of clients matching a certain rule. The filter table now\r\nlooks like this:\r\n\r\n```C\r\nstatic const const Rule rules[] = {\r\n    /* class                    instance    title       tags mask     isfloating   monitor  opacity */\r\n    { \"Iceweasel\",              NULL,       NULL,       1 << 1,       False,       -1,      1.0 },\r\n    { \"mplayer2\",               NULL,       NULL,       1,            True,        -1,      1.0 },\r\n    { \"mpv\",                    NULL,       NULL,       1,            True,        -1,      1.0 },\r\n    { \"URxvt\",                  NULL,       NULL,       1 << 0,       False,       -1,      0.9 }};\r\n```\r\n\r\nNote the new \"opacity\" field. The number here must be a double d 0.0 <=\r\nd <= 1.0 with 0.0 meaning 100% transparent (=invisible) and 1.0 opaque\r\n(=no transparency). Values which are out of bounds will be sanitized and\r\ndefault to 1.0, though.\r\n\r\nThe default opacity for clients not matching any rule is = 1.0.\r\n\r\n### changeopacity(const Arg \\*arg)\r\n\r\nThis callback can be used in keybindings. arg needs to have its float\r\nmember set to a positive or negative number; when called, the value will\r\nbe added to the client's opacity as explained above. Values f > 0.0 will\r\nincrease the opacity until its value reaches 1.0, values f < 0.0 will\r\ndecrease the opacity. Out of bound values will default to 1.0 (fully\r\nopaque). Example configuration snippet:\r\n\r\n```C\r\n\r\n    { MODKEY,                       XK_o,      changeopacity,   {.f = +0.05 }},\r\n    { MODKEY|ShiftMask,             XK_o,      changeopacity,   {.f = -0.05 }},\r\n```\r\n\r\n### setopacity(const Arg \\*arg)\r\n\r\nLike changeopacity(), but sets the opacity of the focus client to a fix\r\nvalue.\r\n\r\n## mpv IPC\r\n\r\nIn `config.h`, set `mpvsocket` to the path to the socket path\r\nconfigured using mpv's `input-unix-socket` option:\r\n\r\n```C\r\nstatic const char mpvsocket[] = \"/home/joj/.mpv.socket\";\r\n```\r\n\r\nand bind the mpv actions to keys in `config.h`, for example:\r\n\r\n```C\r\n{ MODKEY, XK_z, mpvcmd, { .i = MpdPrev }},\r\n{ MODKEY, XK_g, mpvcmd, { .i = MpvToggle }},\r\n{ MODKEY, XK_v, mpvcmd, { .i = MpvNext }},\r\n```\r\n\r\nAvailable actions are defined as follows:\r\n\r\n```C\r\nenum { MpvToggle, MpvNext, MpvPrev, MpvMuteVolume, MpvRaiseVolume, MpvLowerVolume };\r\n```\r\n\r\nTheir effects correspond to their mpd equivalents.\r\n","google":"UA-53661859-2","note":"Don't delete this file! It's used internally to help with page regeneration."}